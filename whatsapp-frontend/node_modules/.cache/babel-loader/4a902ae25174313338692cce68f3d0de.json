{"ast":null,"code":"const util = require(\"./util\");\n\nconst nacl = require(\"tweetnacl\");\n\nconst naclUtil = require(\"tweetnacl-util\");\n\nfunction encrypt(pusher, channel, data) {\n  if (pusher.config.encryptionMasterKey === undefined) {\n    throw new Error(\"Set encryptionMasterKey before triggering events on encrypted channels\");\n  }\n\n  const nonceBytes = nacl.randomBytes(24);\n  const ciphertextBytes = nacl.secretbox(naclUtil.decodeUTF8(JSON.stringify(data)), nonceBytes, pusher.channelSharedSecret(channel));\n  return JSON.stringify({\n    nonce: naclUtil.encodeBase64(nonceBytes),\n    ciphertext: naclUtil.encodeBase64(ciphertextBytes)\n  });\n}\n\nexports.trigger = function (pusher, channels, eventName, data, socketId) {\n  if (channels.length === 1 && util.isEncryptedChannel(channels[0])) {\n    const channel = channels[0];\n    const event = {\n      name: eventName,\n      data: encrypt(pusher, channel, data),\n      channels: [channel]\n    };\n\n    if (socketId) {\n      event.socket_id = socketId;\n    }\n\n    return pusher.post({\n      path: \"/events\",\n      body: event\n    });\n  } else {\n    for (let i = 0; i < channels.length; i++) {\n      if (util.isEncryptedChannel(channels[i])) {\n        // For rationale, see limitations of end-to-end encryption in the README\n        throw new Error(\"You cannot trigger to multiple channels when using encrypted channels\");\n      }\n    }\n\n    const event = {\n      name: eventName,\n      data: ensureJSON(data),\n      channels: channels\n    };\n\n    if (socketId) {\n      event.socket_id = socketId;\n    }\n\n    return pusher.post({\n      path: \"/events\",\n      body: event\n    });\n  }\n};\n\nexports.triggerBatch = function (pusher, batch) {\n  for (let i = 0; i < batch.length; i++) {\n    batch[i].data = util.isEncryptedChannel(batch[i].channel) ? encrypt(pusher, batch[i].channel, batch[i].data) : ensureJSON(batch[i].data);\n  }\n\n  return pusher.post({\n    path: \"/batch_events\",\n    body: {\n      batch: batch\n    }\n  });\n};\n\nfunction ensureJSON(data) {\n  return typeof data === \"string\" ? data : JSON.stringify(data);\n}","map":{"version":3,"sources":["/Users/yellr1/WhatsApp-Clone/whatsapp-clone/whatsapp-frontend/node_modules/pusher/lib/events.js"],"names":["util","require","nacl","naclUtil","encrypt","pusher","channel","data","config","encryptionMasterKey","undefined","Error","nonceBytes","randomBytes","ciphertextBytes","secretbox","decodeUTF8","JSON","stringify","channelSharedSecret","nonce","encodeBase64","ciphertext","exports","trigger","channels","eventName","socketId","length","isEncryptedChannel","event","name","socket_id","post","path","body","i","ensureJSON","triggerBatch","batch"],"mappings":"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","sourcesContent":["const util = require(\"./util\")\nconst nacl = require(\"tweetnacl\")\nconst naclUtil = require(\"tweetnacl-util\")\n\nfunction encrypt(pusher, channel, data) {\n  if (pusher.config.encryptionMasterKey === undefined) {\n    throw new Error(\n      \"Set encryptionMasterKey before triggering events on encrypted channels\"\n    )\n  }\n\n  const nonceBytes = nacl.randomBytes(24)\n\n  const ciphertextBytes = nacl.secretbox(\n    naclUtil.decodeUTF8(JSON.stringify(data)),\n    nonceBytes,\n    pusher.channelSharedSecret(channel)\n  )\n\n  return JSON.stringify({\n    nonce: naclUtil.encodeBase64(nonceBytes),\n    ciphertext: naclUtil.encodeBase64(ciphertextBytes),\n  })\n}\n\nexports.trigger = function (pusher, channels, eventName, data, socketId) {\n  if (channels.length === 1 && util.isEncryptedChannel(channels[0])) {\n    const channel = channels[0]\n    const event = {\n      name: eventName,\n      data: encrypt(pusher, channel, data),\n      channels: [channel],\n    }\n    if (socketId) {\n      event.socket_id = socketId\n    }\n    return pusher.post({ path: \"/events\", body: event })\n  } else {\n    for (let i = 0; i < channels.length; i++) {\n      if (util.isEncryptedChannel(channels[i])) {\n        // For rationale, see limitations of end-to-end encryption in the README\n        throw new Error(\n          \"You cannot trigger to multiple channels when using encrypted channels\"\n        )\n      }\n    }\n\n    const event = {\n      name: eventName,\n      data: ensureJSON(data),\n      channels: channels,\n    }\n    if (socketId) {\n      event.socket_id = socketId\n    }\n    return pusher.post({ path: \"/events\", body: event })\n  }\n}\n\nexports.triggerBatch = function (pusher, batch) {\n  for (let i = 0; i < batch.length; i++) {\n    batch[i].data = util.isEncryptedChannel(batch[i].channel)\n      ? encrypt(pusher, batch[i].channel, batch[i].data)\n      : ensureJSON(batch[i].data)\n  }\n  return pusher.post({ path: \"/batch_events\", body: { batch: batch } })\n}\n\nfunction ensureJSON(data) {\n  return typeof data === \"string\" ? data : JSON.stringify(data)\n}\n"]},"metadata":{},"sourceType":"script"}